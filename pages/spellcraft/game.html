<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KrazyPlace ‚Äî Spellcraft</title>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <style>
    html, body { height: 100%; margin: 0; display: flex; flex-direction: column; }
    main { flex: 1; }
    .hero { padding: 0.5rem; text-align: center; }
    .container-narrow { max-width: 1000px; margin: auto; }
    .daily-box { background: var(--surface-2); border-radius: var(--border-radius); padding: 1.5rem; margin-top: 1rem; }
    .panel { display:flex; gap:1rem; flex-wrap:wrap; justify-content:center; }
    .fragment, .monster, .slot { background: var(--surface-3); border-radius: var(--border-radius, 0.25rem); padding:0.6rem; margin:0.3rem; width:220px; }
    .fragment:hover, .monster:hover { transform: scale(1.03); cursor:pointer; }
    .fragment.selected { border:3px solid var(--primary); box-shadow:0 0 8px var(--primary); }
    .slot { min-height:56px; display:flex; align-items:center; justify-content:center; }
    .monster.dead { opacity:0.4; filter:grayscale(0.6); }
    .controls { display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap; }
    .stats { text-align:left; }
    .log { max-height:240px; overflow:auto; white-space:pre-wrap; background:var(--surface-1); padding:0.6rem; border-radius:6px; }
    footer { text-align: center; margin-top: 1rem; border-top: 1px solid var(--surface-3); padding-top: 1rem; }
  </style>
</head>
<body>
  <header class="container container-narrow">
    <nav>
      <ul>
        <li class="logo"><a href="/krazyplace">KrazyPlace</a></li>
        <li><a href="#">Spellcraft</a></li>
      </ul>
    </nav>
  </header>

  <main class="container container-narrow">
    <section class="hero">
      <h1>Spellcraft ‚Äî Construis tes sorts</h1>
      <p>Choisis √† plusieurs reprises (parmi 3) des fragments de sorts, assemble-les, r√©arrange entre chaque vague, et lance le sort pour affronter la vague.</p>

      <div style="margin: 1rem 0;" class="controls">
        <button id="dailyGameBtn">Partie du jour üåû</button>
        <button id="randomGameBtn">Partie al√©atoire üé≤</button>
      </div>

      <div class="daily-box" id="gameBox" style="display:none;">
        <h3 id="phaseTitle">Pr√©paration</h3>
        <div style="display:flex; gap:1rem; flex-wrap:wrap; justify-content:center;">
          <div style="min-width:260px;">
            <h4>Fragments propos√©s</h4>
            <div id="choices" class="panel"></div>
            <p style="text-align:center; margin-top:0.4rem;"><small>Clique pour choisir un fragment ‚Äî tu peux choisir jusqu'√† 3 fragments pour composer un sort (tu peux t'arr√™ter avant).
            </small></p>
            <div style="margin-top:0.5rem; text-align:center;">
              <button id="addFragmentBtn">‚úö Ajouter un fragment (max 3)</button>
              <button id="shuffleChoicesBtn">üîÄ Renouveler les 3 choix</button>
            </div>
          </div>

          <div style="min-width:300px;">
            <h4>Sort en cours (ordre = gauche ‚Üí droite)</h4>
            <div id="spellSlots" class="panel"></div>
            <div style="margin-top:0.4rem; text-align:center;" class="controls">
              <button id="castBtn">üî• Lancer le sort</button>
              <button id="clearSpellBtn">üóëÔ∏è Effacer</button>
              <button id="reorderBtn">‚ÜîÔ∏è R√©arranger</button>
            </div>
            <p style="font-size:0.9rem; margin-top:0.4rem;">Objectif : terminer toutes les vagues en lan√ßant le moins de sorts possible et en infligeant le plus de d√©g√¢ts (overkill compt√©).</p>
          </div>

          <div style="min-width:320px;">
            <h4>Vague actuelle</h4>
            <div id="waveInfo"></div>
            <div id="monsters" class="panel" style="margin-top:0.6rem;"></div>
            <div style="margin-top:0.6rem;">
              <p class="stats"><strong>Statistiques :</strong></p>
              <p id="statSpells">Sorts lanc√©s : 0</p>
              <p id="statDamage">D√©g√¢ts totaux (incl. overkill) : 0</p>
            </div>
          </div>
        </div>

        <hr>
        <div style="display:flex; gap:1rem; align-items:flex-start;">
          <div style="flex:1;">
            <h4>Journal</h4>
            <div id="log" class="log"></div>
          </div>
          <div style="width:260px;">
            <h4>R√®gles rapides</h4>
            <ul>
              <li>Choisis jusqu'√† 3 fragments ‚Äî l'ordre change l'effet.</li>
              <li>Fragments : Feu, Poison, Marque, Crit, Zone, Perc√©e, Soins...</li>
              <li>Marque augmente le prochain d√©g√¢t sur la cible (+% ou +flat).</li>
              <li>Crit : chance d'appliquer un multiplicateur sur une attaque.</li>
              <li>Poison/Br√ªlure : d√©g√¢t sur la dur√©e appliqu√© chaque round.</li>
              <li>Apr√®s chaque vague, les fragments sont rem√©lang√©s et tu peux modifier ton sort.
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div id="endGame" style="display:none; margin-top:2rem;">
        <h2 id="endTitle">Fin de partie</h2>
        <p id="endSummary"></p>
      </div>
    </section>
  </main>

  <footer><p>¬© KrazyPlace ‚Äî Spellcraft</p></footer>

  <script>
  // PRNG same as original
  function pseudoRandom(seed) {
    let s = seed;
    return () => { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; };
  }

  // --- Game data ---
  const FRAGMENTS_POOL = [
    { id: 'fire', name: 'Flamme', desc: 'D√©g√¢ts imm√©diats + br√ªlure', type:'damage', base: 60, dot: 10 },
    { id: 'poison', name: 'Poison', desc: 'D√©g√¢ts sur la dur√©e', type:'dot', base: 10, duration: 3 },
    { id: 'mark', name: 'Marque', desc: 'Augmente le prochain d√©g√¢t sur la cible', type:'mark', addFlat:30 },
    { id: 'crit', name: 'Frappe critique', desc: 'Augmente la probabilit√© de critique', type:'crit', critBonus:0.25 },
    { id: 'aoe', name: 'Onde', desc: 'Attaque de zone (tous les ennemis)', type:'aoe' },
    { id: 'pierce', name: 'Perc√©e', desc: 'Ignorer une partie de la d√©fense (bonus contre armure fictive)', type:'pierce', bonus: 20 },
    { id: 'heal', name: 'Soin', desc: 'Soigne l√©g√®rement (utile si tu ajoutes un m√©canisme de h√©ros)', type:'heal', base:40 },
    { id: 'shard', name: 'Fragment brut', desc: 'Petit d√©g√¢t polyvalent', type:'damage', base:30 },
  ];

  const wavesConfig = [
    { n:3, baseHp:80 },
    { n:3, baseHp:120 },
    { n:4, baseHp:160 },
    { n:4, baseHp:230 },
    { n:5, baseHp:330 }
  ];

  // --- State ---
  let rng, seedGlobal;
  let choices = [];
  let spell = []; // ordered array of fragment objects
  let waveIndex = 0;
  let monsters = [];
  let spellsCast = 0;
  let totalDamage = 0;

  // DOM
  const choicesDiv = document.getElementById('choices');
  const slotsDiv = document.getElementById('spellSlots');
  const waveInfo = document.getElementById('waveInfo');
  const monstersDiv = document.getElementById('monsters');
  const logDiv = document.getElementById('log');
  const statSpells = document.getElementById('statSpells');
  const statDamage = document.getElementById('statDamage');

  // Buttons
  document.getElementById('dailyGameBtn').onclick = () => {
    const today = new Date().toISOString().split('T')[0];
    const seed = today.split('').reduce((a,c)=>a+c.charCodeAt(0),0);
    startGame(seed);
  };
  document.getElementById('randomGameBtn').onclick = () => {
    const seed = Math.floor(Math.random() * 2147483647);
    startGame(seed);
  };
  document.getElementById('addFragmentBtn').onclick = () => addChosenFragment();
  document.getElementById('shuffleChoicesBtn').onclick = () => generateChoices();
  document.getElementById('castBtn').onclick = () => castSpell();
  document.getElementById('clearSpellBtn').onclick = () => { spell = []; renderSpellSlots(); };
  document.getElementById('reorderBtn').onclick = () => reorderSpell();

  // --- Core functions ---
  function startGame(seed) {
    seedGlobal = seed;
    rng = pseudoRandom(seed);
    choices = [];
    spell = [];
    waveIndex = 0;
    spellsCast = 0;
    totalDamage = 0;
    monsters = [];
    document.getElementById('gameBox').style.display = 'block';
    document.getElementById('endGame').style.display = 'none';
    log('Nouvelle partie ‚Äî seed: ' + seed);
    generateChoices();
    spawnWave();
    updateStats();
  }

  function log(text) {
    const time = new Date().toLocaleTimeString();
    logDiv.textContent = `[${time}] ${text}\n` + logDiv.textContent;
  }

  function sampleFromPool() {
    // return a deep-ish copy of a fragment with some randomness to scale
    const idx = Math.floor(rng() * FRAGMENTS_POOL.length);
    const base = FRAGMENTS_POOL[idx];
    return JSON.parse(JSON.stringify(base));
  }

  function generateChoices() {
    choices = [sampleFromPool(), sampleFromPool(), sampleFromPool()];
    renderChoices();
  }

  function renderChoices() {
    choicesDiv.innerHTML = '';
    choices.forEach((c, i) => {
      const d = document.createElement('div');
      d.className = 'fragment';
      d.innerHTML = `<strong>${c.name}</strong><br><small>${c.desc}</small><br><div style="margin-top:6px;text-align:center;"><button data-i='${i}'>Choisir</button></div>`;
      d.querySelector('button').onclick = (e) => { e.stopPropagation(); chooseFragment(i); };
      d.onclick = () => chooseFragment(i);
      choicesDiv.appendChild(d);
    });
  }

  function chooseFragment(i) {
    if (spell.length >= 3) { alert('Tu peux mettre au maximum 3 fragments dans un sort.'); return; }
    const frag = choices[i];
    spell.push(frag);
    log(`Tu as ajout√© ¬´${frag.name}¬ª au sort.`);
    // refresh choices: replace chosen index with a new one
    choices[i] = sampleFromPool();
    renderChoices();
    renderSpellSlots();
  }

  function addChosenFragment() {
    // default: add first available choice
    if (choices.length === 0) return;
    chooseFragment(0);
  }

  function renderSpellSlots() {
    slotsDiv.innerHTML = '';
    for (let i=0;i<3;i++){
      const s = document.createElement('div');
      s.className = 'slot';
      if (spell[i]) {
        s.innerHTML = `<div style="text-align:center;"><strong>${spell[i].name}</strong><br><small>${spell[i].desc}</small><br><button data-i='${i}'>‚úñ</button></div>`;
        s.querySelector('button').onclick = (e)=>{ e.stopPropagation(); removeFragment(i); };
      } else {
        s.innerHTML = `<em>vide</em>`;
      }
      slotsDiv.appendChild(s);
    }
  }

  function removeFragment(i) { spell.splice(i,1); renderSpellSlots(); log('Fragment retir√©.'); }

  function reorderSpell() {
    if (spell.length < 2) return alert('Rien √† r√©arranger.');
    // simple: reverse order for now (user can later request drag&drop)
    spell.reverse();
    renderSpellSlots();
    log('Ordre du sort invers√© (simple r√©arrangement).');
  }

  function spawnWave() {
    if (waveIndex >= wavesConfig.length) { endGame(true); return; }
    const cfg = wavesConfig[waveIndex];
    monsters = [];
    for (let i=0;i<cfg.n;i++){
      const hp = Math.floor(cfg.baseHp + rng() * cfg.baseHp*0.5);
      monsters.push({ id:i, hp, maxHp:hp, dots:[], marks:0 });
    }
    renderWave();
    log(`Vague ${waveIndex+1} : ${monsters.length} monstres (HP ‚âà ${cfg.baseHp}).`);
  }

  function renderWave() {
    waveInfo.innerHTML = `<strong>Vague ${waveIndex+1} / ${wavesConfig.length}</strong>`;
    monstersDiv.innerHTML = '';
    monsters.forEach((m, i) => {
      const d = document.createElement('div');
      d.className = 'monster' + (m.hp<=0?' dead':'');
      d.innerHTML = `<strong>Monstre #${i+1}</strong><br>HP: ${m.hp} / ${m.maxHp}`;
      monstersDiv.appendChild(d);
    });
  }

  function pickTarget() {
    // pick the alive monster with lowest hp (greedy, to maximize overkill counting tactic)
    const alive = monsters.filter(m=>m.hp>0);
    if (alive.length===0) return null;
    // prefer the one with lowest hp to exploit overkill
    alive.sort((a,b)=>a.hp-b.hp);
    return alive[0];
  }

  function applyDOTs() {
    // apply poison/burn each "round" (we consider each cast a round)
    let dotDamage = 0;
    monsters.forEach(m=>{
      if (m.hp<=0) return;
      if (m.dots && m.dots.length>0){
        m.dots = m.dots.filter(d=>{
          m.hp -= d.amount;
          dotDamage += d.amount;
          d.remaining -= 1;
          return d.remaining > 0;
        });
      }
    });
    if (dotDamage>0) {
      totalDamage += dotDamage; updateStats(); log(`Effets sur la dur√©e infligent ${dotDamage} d√©g√¢ts.`);
      renderWave();
    }
  }

  function castSpell() {
    if (spell.length===0) return alert('Compose d\'abord un sort (jusqu\'√† 3 fragments).');
    const target = pickTarget();
    if (!target) { log('Aucun ennemi vivant.'); return; }
    spellsCast += 1;
    let castDamage = 0;
    let isAoE = false;
    let critMult = 1;
    let markBonus = 0;
    // iterate fragments in order
    spell.forEach(f=>{
      if (f.type === 'damage') {
        const dmg = f.base;
        castDamage += dmg;
      } else if (f.type === 'dot') {
        // apply DOT to target
        target.dots.push({ amount: f.base || 10, remaining: f.duration || 3 });
      } else if (f.type === 'mark') {
        // add flat bonus for next damage on target
        target.marks += f.addFlat || 0;
      } else if (f.type === 'crit') {
        // simple model: add chance to multiply final damage
        const chance = (f.critBonus || 0.15) + (rng()*0.05);
        if (rng() < chance) { critMult = 1.75; }
      } else if (f.type === 'aoe') {
        isAoE = true;
      } else if (f.type === 'pierce') {
        // pierce as bonus damage
        castDamage += (f.bonus || 20);
      } else if (f.type === 'heal') {
        // not used on monsters, could heal player in future
      }
    });

    // apply mark bonus and crit
    // if AoE: damage applied to all alive monsters
    let damageThisCast = 0;
    if (isAoE) {
      monsters.forEach(m=>{
        if (m.hp<=0) return;
        let applied = Math.floor((castDamage + (m.marks || 0)) * critMult);
        // mark applies per target then consumed
        applied += (m.marks || 0);
        // consume marks
        m.marks = 0;
        // apply damage and count overkill
        const before = m.hp;
        m.hp -= applied;
        const dealt = before - Math.max(0,m.hp);
        damageThisCast += dealt;
      });
      totalDamage += damageThisCast;
      log(`Sort AoE inflige ${damageThisCast} d√©g√¢ts au total.`);
    } else {
      // single target
      let applied = Math.floor((castDamage + (target.marks || 0)) * critMult);
      applied += (target.marks || 0);
      target.marks = 0;
      const before = target.hp;
      target.hp -= applied;
      const dealt = before - Math.max(0,target.hp);
      damageThisCast += dealt;
      totalDamage += damageThisCast;
      log(`Sort inflige ${damageThisCast} d√©g√¢ts au Monstre #${target.id+1}.`);
    }

    // After cast, apply immediate DOT ticks (we treat DOT tick once per cast as "round")
    applyDOTs();

    // Remove dead monsters and advance if wave cleared
    renderWave();
    updateStats();
    // clear spell for next time (player can recompose between waves) ‚Äî but we keep it so they can tweak
    // reduce durations handled in applyDOTs

    // If any monster died this cast, log
    monsters.forEach((m,i)=>{ if (m.hp<=0) log(`Monstre #${i+1} est vaincu !`); });

    // Check if wave cleared
    const alive = monsters.filter(m=>m.hp>0);
    if (alive.length === 0) {
      log(`Vague ${waveIndex+1} √©limin√©e en ${spellsCast} sorts jusqu\'√† pr√©sent.`);
      waveIndex += 1;
      // reshuffle choices and allow recompose
      generateChoices();
      if (waveIndex >= wavesConfig.length) { endGame(true); return; }
      // spawn next wave
      spawnWave();
    }

    updateStats();
  }

  function updateStats() {
    statSpells.textContent = `Sorts lanc√©s : ${spellsCast}`;
    statDamage.textContent = `D√©g√¢ts totaux (incl. overkill) : ${totalDamage}`;
  }

  function endGame(victory) {
    document.getElementById('gameBox').style.display = 'none';
    document.getElementById('endGame').style.display = 'block';
    document.getElementById('endTitle').textContent = victory ? 'üèÜ Victoire !' : 'üíÄ D√©faite';
    document.getElementById('endSummary').textContent = `R√©sultat : ${victory ? 'Victoire' : 'D√©faite'}. Vagues termin√©es : ${Math.min(waveIndex, wavesConfig.length)} / ${wavesConfig.length}. Sorts lanc√©s : ${spellsCast}. D√©g√¢ts totaux : ${totalDamage} (overkill inclus). Seed: ${seedGlobal}`;
    log('Partie termin√©e.');
  }

  // initial render placeholders
  renderChoices(); renderSpellSlots();
  </script>
</body>
</html>
